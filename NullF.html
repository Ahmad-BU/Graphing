<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Fusion</title>
    <style>
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            background: #f5f5f7;
            margin: 0;
            padding: 0;
        }
        .container {
            max-width: 700px;
            margin: 40px auto;
            background: #fff;
            border-radius: 10px;
            box-shadow: 0 2px 8px #ccc;
            padding: 32px;
        }
        nav {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 24px;
        }
        nav button {
            padding: 8px 20px;
            border-radius: 4px;
            border: none;
            background: #0071e3;
            color: #fff;
            font-size: 1em;
            cursor: pointer;
            transition: background 0.2s;
        }
        nav button.active {
            background: #005bb5;
        }
        form {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 24px;
        }
        input[type="number"], input[type="text"] {
            width: 80px;
            padding: 6px;
            border-radius: 4px;
            border: 1px solid #bbb;
            font-size: 1em;
            font-family: 'Segoe UI', Arial, sans-serif;
        }
        button[type="submit"], .calc-btn {
            padding: 6px 18px;
            border-radius: 4px;
            border: none;
            background: #0071e3;
            color: #fff;
            font-size: 1em;
            cursor: pointer;
        }
        canvas {
            display: block;
            margin: 0 auto;
            background: #f5f5f7;
            border: 1px solid #ddd;
            border-radius: 6px;
            outline: none;
        }
        .points {
            margin-top: 24px;
            background: #f8f8fa;
            border-radius: 8px;
            padding: 16px;
            font-size: 1.1em;
            min-height: 24px;
        }
        .points strong {
            color: #0071e3;
        }
        .hidden {
            display: none;
        }
        .calc-row {
            margin: 18px 0 0 0;
            text-align: center;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 18px;
        }
        .calc-group {
            display: flex;
            align-items: center;
            gap: 8px;
            background: #f1f6fa;
            border-radius: 6px;
            padding: 10px 16px;
            margin-bottom: 0;
            box-shadow: 0 1px 2px #e0e0e0;
        }
        .calc-result {
            margin-left: 12px;
            color: #0071e3;
            font-weight: 600;
            font-size: 1.08em;
            min-width: 90px;
            display: inline-block;
        }
        .logo-row {
            display:flex;
            align-items:center;
            justify-content:center;
            margin-bottom:18px;
        }
        .tooltip {
            position: absolute;
            pointer-events: none;
            background: #fff;
            border: 1px solid #0071e3;
            color: #222;
            border-radius: 6px;
            padding: 6px 12px;
            font-size: 1em;
            font-family: 'Segoe UI', Arial, sans-serif;
            box-shadow: 0 2px 8px #bbb;
            z-index: 1000;
            white-space: nowrap;
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Fusion Logo and Name -->
        <div class="logo-row">
            <svg width="48" height="48" viewBox="0 0 48 48" style="margin-right:14px;">
                <defs>
                    <linearGradient id="fusionGradient" x1="0" y1="0" x2="1" y2="1">
                        <stop offset="0%" stop-color="#0071e3"/>
                        <stop offset="100%" stop-color="#34c759"/>
                    </linearGradient>
                </defs>
                <circle cx="24" cy="24" r="20" fill="url(#fusionGradient)"/>
                <text x="24" y="31" text-anchor="middle" font-size="26" font-family="Segoe UI, Arial, sans-serif" fill="#fff" font-weight="bold">F</text>
            </svg>
            <span style="font-size:2.1em;font-weight:bold;letter-spacing:2px;color:#222;font-family:'Segoe UI',Arial,sans-serif;">
                <span style="color:#0071e3;">Fusion</span>
                <span style="font-size:0.6em;color:#888;font-weight:normal;margin-left:8px;">Grapher</span>
            </span>
        </div>
        <nav>
            <button id="quadTab" class="active">Quadratic (ax²+bx+c=0)</button>
            <button id="cubicTab">Cubic (ax³+bx²+cx+d=0)</button>
            <button id="linearTab">Linear (y=mx+b)</button>
        </nav>
        <!-- Quadratic Page -->
        <div id="quadPage">
            <form id="quadForm">
                <label>
                    Equation (e.g. 2x^2-3x+1=0): 
                    <input type="text" id="quadEq" value="x^2" style="width:220px;">
                </label>
                <button type="submit">Draw</button>
            </form>
            <div style="text-align:center; margin-bottom:10px;">
                <span id="quadParsed" style="color:#888; font-size:0.95em;"></span>
            </div>
            <div style="position:relative;">
                <canvas id="quadGraph" width="500" height="400" tabindex="0"></canvas>
                <div id="quadTooltip" class="tooltip"></div>
            </div>
            <div class="calc-row">
                <div class="calc-group">
                    <label>x:</label>
                    <input type="number" id="quadX" step="any">
                    <button type="button" class="calc-btn" id="calcQuadY">Calc y</button>
                    <span id="quadCalcYResult" class="calc-result"></span>
                </div>
                <div class="calc-group">
                    <label>y:</label>
                    <input type="number" id="quadY" step="any">
                    <button type="button" class="calc-btn" id="calcQuadX">Calc x</button>
                    <span id="quadCalcXResult" class="calc-result"></span>
                </div>
            </div>
            <div class="points" id="quadPoints"></div>
        </div>
        <!-- Cubic Page -->
        <div id="cubicPage" class="hidden">
            <form id="cubicForm">
                <label>
                    Equation (e.g. x^3-2x^2+3x-1=0): 
                    <input type="text" id="cubicEq" value="x^3" style="width:220px;">
                </label>
                <button type="submit">Draw</button>
            </form>
            <div style="text-align:center; margin-bottom:10px;">
                <span id="cubicParsed" style="color:#888; font-size:0.95em;"></span>
            </div>
            <div style="position:relative;">
                <canvas id="cubicGraph" width="500" height="400" tabindex="0"></canvas>
                <div id="cubicTooltip" class="tooltip"></div>
            </div>
            <div class="calc-row">
                <div class="calc-group">
                    <label>x:</label>
                    <input type="number" id="cubicX" step="any">
                    <button type="button" class="calc-btn" id="calcCubicY">Calc y</button>
                    <span id="cubicCalcYResult" class="calc-result"></span>
                </div>
                <div class="calc-group">
                    <label>y:</label>
                    <input type="number" id="cubicY" step="any">
                    <button type="button" class="calc-btn" id="calcCubicX">Calc x</button>
                    <span id="cubicCalcXResult" class="calc-result"></span>
                </div>
            </div>
            <div class="points" id="cubicPoints"></div>
        </div>
        <!-- Linear Page -->
        <div id="linearPage" class="hidden">
            <form id="linearForm">
                <label>
                    Equation (e.g. y=2x+1): 
                    <input type="text" id="linearEq" value="y=x" style="width:180px;">
                </label>
                <button type="submit">Draw</button>
            </form>
            <div style="text-align:center; margin-bottom:10px;">
                <span id="linearParsed" style="color:#888; font-size:0.95em;"></span>
            </div>
            <div style="position:relative;">
                <canvas id="linearGraph" width="500" height="400" tabindex="0"></canvas>
                <div id="linearTooltip" class="tooltip"></div>
            </div>
            <div class="calc-row">
                <div class="calc-group">
                    <label>x:</label>
                    <input type="number" id="linearX" step="any">
                    <button type="button" class="calc-btn" id="calcLinearY">Calc y</button>
                    <span id="linearCalcYResult" class="calc-result"></span>
                </div>
                <div class="calc-group">
                    <label>y:</label>
                    <input type="number" id="linearY" step="any">
                    <button type="button" class="calc-btn" id="calcLinearX">Calc x</button>
                    <span id="linearCalcXResult" class="calc-result"></span>
                </div>
            </div>
            <div class="points" id="linearPoints"></div>
        </div>
    </div>
    <script>
        // --- Grid Drawing Utility ---
        function drawGrid(ctx, canvas, scale, offsetX, offsetY) {
            ctx.save();
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Grid color and style
            ctx.strokeStyle = "#e0e6f0";
            ctx.lineWidth = 1;

            const xOffset = canvas.width / 2 + offsetX * scale;
            const yOffset = canvas.height / 2 + offsetY * scale;

            // Find grid step (1, 2, 5, 10, 20, etc.) based on scale
            let step = 1;
            if (scale < 12) step = 10;
            else if (scale < 25) step = 5;
            else if (scale < 50) step = 2;

            // Draw vertical grid lines
            for (let gx = xOffset % (step * scale); gx < canvas.width; gx += step * scale) {
                ctx.beginPath();
                ctx.moveTo(gx, 0);
                ctx.lineTo(gx, canvas.height);
                ctx.stroke();
            }
            // Draw horizontal grid lines
            for (let gy = yOffset % (step * scale); gy < canvas.height; gy += step * scale) {
                ctx.beginPath();
                ctx.moveTo(0, gy);
                ctx.lineTo(canvas.width, gy);
                ctx.stroke();
            }

            // Draw numbers if zoomed in enough (scale >= 30)
            if (scale >= 30) {
                ctx.fillStyle = "#b0b0b0";
                ctx.font = "12px 'Segoe UI', Arial, sans-serif";
                ctx.textAlign = "center";
                ctx.textBaseline = "top";
                // X numbers
                for (let gx = xOffset % (step * scale), i = -Math.floor(xOffset / (step * scale)); gx < canvas.width; gx += step * scale, i++) {
                    let xVal = Math.round(((gx - xOffset) / scale + Number.EPSILON) * 100) / 100;
                    if (Math.abs(xVal) < 1e-8) xVal = 0;
                    if (Math.abs(gx - xOffset) > 2) // Don't draw at y axis
                        ctx.fillText(xVal, gx, yOffset + 2);
                }
                // Y numbers
                ctx.textAlign = "right";
                ctx.textBaseline = "middle";
                for (let gy = yOffset % (step * scale), i = -Math.floor(yOffset / (step * scale)); gy < canvas.height; gy += step * scale, i++) {
                    let yVal = Math.round(((yOffset - gy) / scale + Number.EPSILON) * 100) / 100;
                    if (Math.abs(yVal) < 1e-8) yVal = 0;
                    if (Math.abs(gy - yOffset) > 2) // Don't draw at x axis
                        ctx.fillText(yVal, xOffset - 4, gy);
                }
            }
            ctx.restore();
        }

        // --- Tooltip logic ---
        function setupTooltip(canvas, tooltip, getPoints, getScaleOffset) {
            canvas.addEventListener('mousemove', function(e) {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                const {scale, offsetX, offsetY} = getScaleOffset();
                const points = getPoints();
                let found = null;
                for (const pt of points) {
                    const xOffset = canvas.width / 2 + offsetX * scale;
                    const yOffset = canvas.height / 2 + offsetY * scale;
                    const px = xOffset + pt.x * scale;
                    const py = yOffset - pt.y * scale;
                    if (Math.abs(mouseX - px) < 12 && Math.abs(mouseY - py) < 12) {
                        found = {label: pt.label, x: px, y: py, text: pt.text};
                        break;
                    }
                }
                if (found) {
                    tooltip.style.display = "block";
                    tooltip.textContent = found.text;
                    tooltip.style.left = (found.x + 18) + "px";
                    tooltip.style.top = (found.y - 18) + "px";
                } else {
                    tooltip.style.display = "none";
                }
            });
            canvas.addEventListener('mouseleave', function() {
                tooltip.style.display = "none";
            });
        }

        // --- Zoom/Pan State ---
        function makeZoomable(canvas, drawFunc, getParams, getPoints, tooltip) {
            let scale = 50; // Start more zoomed in
            let offsetX = 0;
            let offsetY = 0;
            let isDragging = false;
            let lastX = 0;
            let lastY = 0;

            function redraw() {
                const params = getParams();
                // Draw grid first
                drawGrid(canvas.getContext('2d'), canvas, scale, offsetX, offsetY);
                // Draw graph
                drawFunc(...params, scale, offsetX, offsetY);
            }

            // Mouse drag to pan (invert y for natural feel)
            canvas.addEventListener('mousedown', function(e) {
                isDragging = true;
                lastX = e.clientX;
                lastY = e.clientY;
                canvas.style.cursor = "grabbing";
            });
            window.addEventListener('mousemove', function(e) {
                if (isDragging) {
                    const dx = e.clientX - lastX;
                    const dy = e.clientY - lastY;
                    offsetX += dx / scale;
                    offsetY += dy / scale; // Invert y direction for "pulling" feel
                    lastX = e.clientX;
                    lastY = e.clientY;
                    redraw();
                }
            });
            window.addEventListener('mouseup', function() {
                isDragging = false;
                canvas.style.cursor = "grab";
            });
            canvas.addEventListener('mouseleave', function() {
                isDragging = false;
                canvas.style.cursor = "grab";
            });
            canvas.addEventListener('mouseenter', function() {
                canvas.style.cursor = "grab";
            });

            // Keyboard controls for zoom only
            canvas.addEventListener('keydown', function(e) {
                let changed = false;
                if (e.key === '+' || e.key === '=' ) {
                    scale *= 1.15;
                    changed = true;
                } else if (e.key === '-' || e.key === '_' ) {
                    scale /= 1.15;
                    changed = true;
                } else if (e.key === '0') {
                    scale = 50; offsetX = 0; offsetY = 0; changed = true;
                }
                if (changed) {
                    e.preventDefault();
                    redraw();
                }
            });

            // Zoom with scroll wheel
            canvas.addEventListener('wheel', function(e) {
                e.preventDefault();
                const zoomFactor = 1.15;
                if (e.deltaY < 0) {
                    scale *= zoomFactor;
                } else {
                    scale /= zoomFactor;
                }
                redraw();
            });

            // Focus on click for keyboard events
            canvas.addEventListener('click', () => canvas.focus());

            // Redraw on window resize
            window.addEventListener('resize', redraw);

            // Tooltip
            if (tooltip && getPoints) {
                setupTooltip(canvas, tooltip, getPoints, () => ({scale, offsetX, offsetY}));
            }

            // Expose redraw for outside triggers
            return function() {
                redraw();
            };
        }

        // Tab switching
        const quadTab = document.getElementById('quadTab');
        const cubicTab = document.getElementById('cubicTab');
        const linearTab = document.getElementById('linearTab');
        const quadPage = document.getElementById('quadPage');
        const cubicPage = document.getElementById('cubicPage');
        const linearPage = document.getElementById('linearPage');

        quadTab.onclick = () => {
            quadTab.classList.add('active');
            cubicTab.classList.remove('active');
            linearTab.classList.remove('active');
            quadPage.classList.remove('hidden');
            cubicPage.classList.add('hidden');
            linearPage.classList.add('hidden');
        };
        cubicTab.onclick = () => {
            cubicTab.classList.add('active');
            quadTab.classList.remove('active');
            linearTab.classList.remove('active');
            cubicPage.classList.remove('hidden');
            quadPage.classList.add('hidden');
            linearPage.classList.add('hidden');
        };
        linearTab.onclick = () => {
            linearTab.classList.add('active');
            quadTab.classList.remove('active');
            cubicTab.classList.remove('active');
            linearPage.classList.remove('hidden');
            quadPage.classList.add('hidden');
            cubicPage.classList.add('hidden');
        };

        // --- Equation Parsing Utilities ---
        function parseQuadratic(eq) {
            eq = eq.replace(/\s+/g, '').replace('=0','');
            let a = 0, b = 0, c = 0;
            let m = eq.match(/([+-]?[\d\.]*)x\^2/);
            if (m) {
                a = m[1] === '' || m[1] === '+' ? 1 : m[1] === '-' ? -1 : parseFloat(m[1]);
                eq = eq.replace(m[0], '');
            }
            m = eq.match(/([+-]?[\d\.]*)x(?![\^])/);
            if (m) {
                b = m[1] === '' || m[1] === '+' ? 1 : m[1] === '-' ? -1 : parseFloat(m[1]);
                eq = eq.replace(m[0], '');
            }
            m = eq.match(/([+-]?[\d\.]+)/);
            if (m) c = parseFloat(m[1]);
            return {a, b, c};
        }

        function parseCubic(eq) {
            eq = eq.replace(/\s+/g, '').replace('=0','');
            let a = 0, b = 0, c = 0, d = 0;
            let m = eq.match(/([+-]?[\d\.]*)x\^3/);
            if (m) {
                a = m[1] === '' || m[1] === '+' ? 1 : m[1] === '-' ? -1 : parseFloat(m[1]);
                eq = eq.replace(m[0], '');
            }
            m = eq.match(/([+-]?[\d\.]*)x\^2/);
            if (m) {
                b = m[1] === '' || m[1] === '+' ? 1 : m[1] === '-' ? -1 : parseFloat(m[1]);
                eq = eq.replace(m[0], '');
            }
            m = eq.match(/([+-]?[\d\.]*)x(?![\^])/);
            if (m) {
                c = m[1] === '' || m[1] === '+' ? 1 : m[1] === '-' ? -1 : parseFloat(m[1]);
                eq = eq.replace(m[0], '');
            }
            m = eq.match(/([+-]?[\d\.]+)/);
            if (m) d = parseFloat(m[1]);
            return {a, b, c, d};
        }

        function parseLinear(eq) {
            eq = eq.replace(/\s+/g, '');
            let m = 1, b = 0;
            let match = eq.match(/^y=([+-]?[\d\.]*)x([+-][\d\.]+)?$/);
            if (match) {
                m = match[1] === '' || match[1] === '+' ? 1 : match[1] === '-' ? -1 : parseFloat(match[1]);
                b = match[2] ? parseFloat(match[2]) : 0;
            } else if (eq.match(/^y=x$/)) {
                m = 1; b = 0;
            } else if (eq.match(/^y=-x$/)) {
                m = -1; b = 0;
            } else if (eq.match(/^y=([+-]?\d+)$/)) {
                m = 0; b = parseFloat(eq.split('=')[1]);
            }
            return {m, b};
        }

        // Draw axes utility
        function drawAxes(ctx, canvas, scale, offsetX, offsetY) {
            ctx.save();
            ctx.strokeStyle = "#bbb";
            ctx.lineWidth = 1.5;
            // X axis
            ctx.beginPath();
            ctx.moveTo(0, canvas.height / 2 + offsetY * scale);
            ctx.lineTo(canvas.width, canvas.height / 2 + offsetY * scale);
            ctx.stroke();
            // Y axis
            ctx.beginPath();
            ctx.moveTo(canvas.width / 2 + offsetX * scale, 0);
            ctx.lineTo(canvas.width / 2 + offsetX * scale, canvas.height);
            ctx.stroke();
            ctx.restore();
        }

        // --- Quadratic Grapher ---
        const quadForm = document.getElementById('quadForm');
        const quadEq = document.getElementById('quadEq');
        const quadParsed = document.getElementById('quadParsed');
        const quadCanvas = document.getElementById('quadGraph');
        const quadCtx = quadCanvas.getContext('2d');
        const quadPointsDiv = document.getElementById('quadPoints');
        const quadTooltip = document.getElementById('quadTooltip');

        let quadSpecialPoints = [];
        function drawQuadratic(a, b, c, scale = 25, offsetX = 0, offsetY = 0) {
            drawAxes(quadCtx, quadCanvas, scale, offsetX, offsetY);
            quadCtx.strokeStyle = "#0071e3";
            quadCtx.lineWidth = 2;
            quadCtx.beginPath();
            const xOffset = quadCanvas.width / 2 + offsetX * scale;
            const yOffset = quadCanvas.height / 2 + offsetY * scale;
            let first = true;
            for (let px = 0; px <= quadCanvas.width; px++) {
                let x = (px - xOffset) / scale;
                let y = a * x * x + b * x + c;
                let py = yOffset - y * scale;
                if (first) {
                    quadCtx.moveTo(px, py);
                    first = false;
                } else {
                    quadCtx.lineTo(px, py);
                }
            }
            quadCtx.stroke();
            // Calculate relevant points
            quadSpecialPoints = [];
            // Vertex
            const xv = -b / (2 * a);
            const yv = a * xv * xv + b * xv + c;
            quadSpecialPoints.push({x: xv, y: yv, label: "Vertex", text: `Vertex: (${xv.toFixed(2)}, ${yv.toFixed(2)})`});
            // Y-intercept (x=0)
            const yint = c;
            quadSpecialPoints.push({x: 0, y: yint, label: "Y-int", text: `Y-intercept: (0, ${yint.toFixed(2)})`});
            // X-intercepts (roots)
            const discriminant = b * b - 4 * a * c;
            if (discriminant > 0) {
                const sqrtD = Math.sqrt(discriminant);
                const x1 = (-b + sqrtD) / (2 * a);
                const x2 = (-b - sqrtD) / (2 * a);
                quadSpecialPoints.push({x: x1, y: 0, label: "Root 1", text: `X-intercept: (${x1.toFixed(2)}, 0)`});
                quadSpecialPoints.push({x: x2, y: 0, label: "Root 2", text: `X-intercept: (${x2.toFixed(2)}, 0)`});
            } else if (discriminant === 0) {
                const x0 = -b / (2 * a);
                quadSpecialPoints.push({x: x0, y: 0, label: "Root", text: `X-intercept: (${x0.toFixed(2)}, 0)`});
            }
            // Draw points
            for (const pt of quadSpecialPoints) {
                quadCtx.beginPath();
                quadCtx.arc(xOffset + pt.x * scale, yOffset - pt.y * scale, 6, 0, 2 * Math.PI);
                quadCtx.fillStyle = "#e34c26";
                quadCtx.fill();
                quadCtx.strokeStyle = "#222";
                quadCtx.lineWidth = 1.5;
                quadCtx.stroke();
            }
            quadPointsDiv.innerHTML = "";
        }
        function getQuadParams() {
            const a = parseFloat(quadForm.dataset.a);
            const b = parseFloat(quadForm.dataset.b);
            const c = parseFloat(quadForm.dataset.c);
            return [a, b, c];
        }
        function getQuadPoints() {
            return quadSpecialPoints;
        }

        quadEq.addEventListener('input', function() {
            const {a, b, c} = parseQuadratic(quadEq.value);
            quadParsed.textContent = `a=${a}, b=${b}, c=${c}`;
        });

        quadForm.addEventListener('submit', function(e) {
            e.preventDefault();
            const {a, b, c} = parseQuadratic(quadEq.value);
            quadParsed.textContent = `a=${a}, b=${b}, c=${c}`;
            quadForm.dataset.a = a;
            quadForm.dataset.b = b;
            quadForm.dataset.c = c;
            quadRedraw();
        });
        quadForm.dataset.a = 1; quadForm.dataset.b = 0; quadForm.dataset.c = 0;

        document.getElementById('calcQuadY').onclick = function() {
            const x = parseFloat(document.getElementById('quadX').value);
            const a = parseFloat(quadForm.dataset.a);
            const b = parseFloat(quadForm.dataset.b);
            const c = parseFloat(quadForm.dataset.c);
            if (!isNaN(x)) {
                const y = a * x * x + b * x + c;
                document.getElementById('quadCalcYResult').textContent = `y = ${y.toFixed(4)}`;
            } else {
                document.getElementById('quadCalcYResult').textContent = '';
            }
        };
        document.getElementById('calcQuadX').onclick = function() {
            const y = parseFloat(document.getElementById('quadY').value);
            const a = parseFloat(quadForm.dataset.a);
            const b = parseFloat(quadForm.dataset.b);
            const c = parseFloat(quadForm.dataset.c);
            if (!isNaN(y)) {
                const d = b * b - 4 * a * (c - y);
                let result = '';
                if (d > 0) {
                    const sqrtD = Math.sqrt(d);
                    const x1 = (-b + sqrtD) / (2 * a);
                    const x2 = (-b - sqrtD) / (2 * a);
                    result = `x = ${x1.toFixed(4)}, ${x2.toFixed(4)}`;
                } else if (d === 0) {
                    const x0 = -b / (2 * a);
                    result = `x = ${x0.toFixed(4)}`;
                } else {
                    result = 'No real solution';
                }
                document.getElementById('quadCalcXResult').textContent = result;
            } else {
                document.getElementById('quadCalcXResult').textContent = '';
            }
        };

        // --- Cubic Grapher ---
        const cubicForm = document.getElementById('cubicForm');
        const cubicEq = document.getElementById('cubicEq');
        const cubicParsed = document.getElementById('cubicParsed');
        const cubicCanvas = document.getElementById('cubicGraph');
        const cubicCtx = cubicCanvas.getContext('2d');
        const cubicPointsDiv = document.getElementById('cubicPoints');
        const cubicTooltip = document.getElementById('cubicTooltip');

        let cubicSpecialPoints = [];
        function drawCubic(a, b, c, d, scale = 25, offsetX = 0, offsetY = 0) {
            drawAxes(cubicCtx, cubicCanvas, scale, offsetX, offsetY);
            cubicCtx.strokeStyle = "#e34c26";
            cubicCtx.lineWidth = 2;
            cubicCtx.beginPath();
            const xOffset = cubicCanvas.width / 2 + offsetX * scale;
            const yOffset = cubicCanvas.height / 2 + offsetY * scale;
            let first = true;
            for (let px = 0; px <= cubicCanvas.width; px++) {
                let x = (px - xOffset) / scale;
                let y = a * x * x * x + b * x * x + c * x + d;
                let py = yOffset - y * scale;
                if (first) {
                    cubicCtx.moveTo(px, py);
                    first = false;
                } else {
                    cubicCtx.lineTo(px, py);
                }
            }
            cubicCtx.stroke();
            // Calculate relevant points
            cubicSpecialPoints = [];
            // Y-intercept (x=0)
            cubicSpecialPoints.push({x: 0, y: d, label: "Y-int", text: `Y-intercept: (0, ${d.toFixed(2)})`});
            // X-intercepts (roots) - approximate numerically
            function cubicRoots(a, b, c, d) {
                const roots = [];
                let lastY = null, lastX = null;
                for (let x = -10; x <= 10; x += 0.01) {
                    let y = a * x * x * x + b * x * x + c * x + d;
                    if (lastY !== null && y * lastY <= 0) {
                        let left = lastX, right = x;
                        for (let i = 0; i < 10; i++) {
                            let mid = (left + right) / 2;
                            let fmid = a * mid * mid * mid + b * mid * mid + c * mid + d;
                            if (Math.abs(fmid) < 1e-6) break;
                            if (fmid * lastY < 0) right = mid;
                            else left = mid;
                        }
                        let root = (left + right) / 2;
                        if (!roots.some(r => Math.abs(r - root) < 0.05)) {
                            roots.push(root);
                        }
                    }
                    lastY = y;
                    lastX = x;
                }
                return roots;
            }
            const roots = cubicRoots(a, b, c, d);
            if (roots.length > 0) {
                roots.forEach((x, i) => {
                    cubicSpecialPoints.push({x: x, y: 0, label: `Root ${i+1}`, text: `X-intercept: (${x.toFixed(2)}, 0)`});
                });
            }
            // Inflection point: x = -b/(3a)
            if (a !== 0) {
                const xi = -b / (3 * a);
                const yi = a * xi * xi * xi + b * xi * xi + c * xi + d;
                cubicSpecialPoints.push({x: xi, y: yi, label: "Inflection", text: `Inflection: (${xi.toFixed(2)}, ${yi.toFixed(2)})`});
            }
            // Draw points
            for (const pt of cubicSpecialPoints) {
                cubicCtx.beginPath();
                cubicCtx.arc(xOffset + pt.x * scale, yOffset - pt.y * scale, 6, 0, 2 * Math.PI);
                cubicCtx.fillStyle = "#e34c26";
                cubicCtx.fill();
                cubicCtx.strokeStyle = "#222";
                cubicCtx.lineWidth = 1.5;
                cubicCtx.stroke();
            }
            cubicPointsDiv.innerHTML = "";
        }
        function getCubicParams() {
            const a = parseFloat(cubicForm.dataset.a);
            const b = parseFloat(cubicForm.dataset.b);
            const c = parseFloat(cubicForm.dataset.c);
            const d = parseFloat(cubicForm.dataset.d);
            return [a, b, c, d];
        }
        function getCubicPoints() {
            return cubicSpecialPoints;
        }

        cubicEq.addEventListener('input', function() {
            const {a, b, c, d} = parseCubic(cubicEq.value);
            cubicParsed.textContent = `a=${a}, b=${b}, c=${c}, d=${d}`;
        });

        cubicForm.addEventListener('submit', function(e) {
            e.preventDefault();
            const {a, b, c, d} = parseCubic(cubicEq.value);
            cubicParsed.textContent = `a=${a}, b=${b}, c=${c}, d=${d}`;
            cubicForm.dataset.a = a;
            cubicForm.dataset.b = b;
            cubicForm.dataset.c = c;
            cubicForm.dataset.d = d;
            cubicRedraw();
        });
        cubicForm.dataset.a = 1; cubicForm.dataset.b = 0; cubicForm.dataset.c = 0; cubicForm.dataset.d = 0;

        document.getElementById('calcCubicY').onclick = function() {
            const x = parseFloat(document.getElementById('cubicX').value);
            const a = parseFloat(cubicForm.dataset.a);
            const b = parseFloat(cubicForm.dataset.b);
            const c = parseFloat(cubicForm.dataset.c);
            const d = parseFloat(cubicForm.dataset.d);
            if (!isNaN(x)) {
                const y = a * x * x * x + b * x * x + c * x + d;
                document.getElementById('cubicCalcYResult').textContent = `y = ${y.toFixed(4)}`;
            } else {
                document.getElementById('cubicCalcYResult').textContent = '';
            }
        };
        document.getElementById('calcCubicX').onclick = function() {
            const y = parseFloat(document.getElementById('cubicY').value);
            const a = parseFloat(cubicForm.dataset.a);
            const b = parseFloat(cubicForm.dataset.b);
            const c = parseFloat(cubicForm.dataset.c);
            const d = parseFloat(cubicForm.dataset.d);
            if (!isNaN(y)) {
                function cubicSolve(a, b, c, d, y) {
                    const roots = [];
                    let lastY = null, lastX = null;
                    for (let x = -100; x <= 100; x += 0.01) {
                        let val = a * x * x * x + b * x * x + c * x + d - y;
                        if (lastY !== null && val * lastY <= 0) {
                            let left = lastX, right = x;
                            for (let i = 0; i < 12; i++) {
                                let mid = (left + right) / 2;
                                let fmid = a * mid * mid * mid + b * mid * mid + c * mid + d - y;
                                if (Math.abs(fmid) < 1e-6) break;
                                if (fmid * lastY < 0) right = mid;
                                else left = mid;
                            }
                            let root = (left + right) / 2;
                            if (!roots.some(r => Math.abs(r - root) < 0.05)) {
                                roots.push(root);
                            }
                        }
                        lastY = val;
                        lastX = x;
                    }
                    return roots;
                }
                const roots = cubicSolve(a, b, c, d, y);
                if (roots.length > 0) {
                    document.getElementById('cubicCalcXResult').textContent =
                        `x = ${roots.map(x => x.toFixed(4)).join(', ')}`;
                } else {
                    document.getElementById('cubicCalcXResult').textContent = 'No real solution';
                }
            } else {
                document.getElementById('cubicCalcXResult').textContent = '';
            }
        };

        // --- Linear Grapher ---
        const linearForm = document.getElementById('linearForm');
        const linearEq = document.getElementById('linearEq');
        const linearParsed = document.getElementById('linearParsed');
        const linearCanvas = document.getElementById('linearGraph');
        const linearCtx = linearCanvas.getContext('2d');
        const linearPointsDiv = document.getElementById('linearPoints');
        const linearTooltip = document.getElementById('linearTooltip');

        let linearSpecialPoints = [];
        function drawLinear(m, b, scale = 25, offsetX = 0, offsetY = 0) {
            drawAxes(linearCtx, linearCanvas, scale, offsetX, offsetY);
            linearCtx.strokeStyle = "#e34c26";
            linearCtx.lineWidth = 2;
            linearCtx.beginPath();
            const xOffset = linearCanvas.width / 2 + offsetX * scale;
            const yOffset = linearCanvas.height / 2 + offsetY * scale;
            let first = true;
            for (let px = 0; px <= linearCanvas.width; px++) {
                let x = (px - xOffset) / scale;
                let y = m * x + b;
                let py = yOffset - y * scale;
                if (first) {
                    linearCtx.moveTo(px, py);
                    first = false;
                } else {
                    linearCtx.lineTo(px, py);
                }
            }
            linearCtx.stroke();
            // Relevant points
            linearSpecialPoints = [];
            // X-intercept (root)
            if (m !== 0) {
                const x0 = -b / m;
                linearSpecialPoints.push({x: x0, y: 0, label: "Root", text: `X-intercept: (${x0.toFixed(2)}, 0)`});
            }
            // Y-intercept (x=0)
            linearSpecialPoints.push({x: 0, y: b, label: "Y-int", text: `Y-intercept: (0, ${b.toFixed(2)})`});
            // Draw points
            for (const pt of linearSpecialPoints) {
                linearCtx.beginPath();
                linearCtx.arc(xOffset + pt.x * scale, yOffset - pt.y * scale, 6, 0, 2 * Math.PI);
                linearCtx.fillStyle = "#e34c26";
                linearCtx.fill();
                linearCtx.strokeStyle = "#222";
                linearCtx.lineWidth = 1.5;
                linearCtx.stroke();
            }
            linearPointsDiv.innerHTML = "";
        }
        function getLinearParams() {
            const m = parseFloat(linearForm.dataset.m);
            const b = parseFloat(linearForm.dataset.b);
            return [m, b];
        }
        function getLinearPoints() {
            return linearSpecialPoints;
        }

        linearEq.addEventListener('input', function() {
            const {m, b} = parseLinear(linearEq.value);
            linearParsed.textContent = `m=${m}, b=${b}`;
        });

        linearForm.addEventListener('submit', function(e) {
            e.preventDefault();
            const {m, b} = parseLinear(linearEq.value);
            linearParsed.textContent = `m=${m}, b=${b}`;
            linearForm.dataset.m = m;
            linearForm.dataset.b = b;
            linearRedraw();
        });
        linearForm.dataset.m = 1; linearForm.dataset.b = 0;

        document.getElementById('calcLinearY').onclick = function() {
            const x = parseFloat(document.getElementById('linearX').value);
            const m = parseFloat(linearForm.dataset.m);
            const b = parseFloat(linearForm.dataset.b);
            if (!isNaN(x)) {
                const y = m * x + b;
                document.getElementById('linearCalcYResult').textContent = `y = ${y.toFixed(4)}`;
            } else {
                document.getElementById('linearCalcYResult').textContent = '';
            }
        };
        document.getElementById('calcLinearX').onclick = function() {
            const y = parseFloat(document.getElementById('linearY').value);
            const m = parseFloat(linearForm.dataset.m);
            const b = parseFloat(linearForm.dataset.b);
            if (!isNaN(y)) {
                if (m !== 0) {
                    const x = (y - b) / m;
                    document.getElementById('linearCalcXResult').textContent = `x = ${x.toFixed(4)}`;
                } else {
                    document.getElementById('linearCalcXResult').textContent = 'No solution (horizontal line)';
                }
            } else {
                document.getElementById('linearCalcXResult').textContent = '';
            }
        };

        // --- Make all graphs zoomable ---
        const quadRedraw = makeZoomable(
            quadCanvas,
            (a, b, c, scale, offsetX, offsetY) => drawQuadratic(a, b, c, scale, offsetX, offsetY),
            () => getQuadParams(),
            getQuadPoints,
            quadTooltip
        );
        const cubicRedraw = makeZoomable(
            cubicCanvas,
            (a, b, c, d, scale, offsetX, offsetY) => drawCubic(a, b, c, d, scale, offsetX, offsetY),
            () => getCubicParams(),
            getCubicPoints,
            cubicTooltip
        );
        const linearRedraw = makeZoomable(
            linearCanvas,
            (m, b, scale, offsetX, offsetY) => drawLinear(m, b, scale, offsetX, offsetY),
            () => getLinearParams(),
            getLinearPoints,
            linearTooltip
        );

        // Initial draws
        quadRedraw();
        cubicRedraw();
        linearRedraw();

        // Redraw on tab switch
        quadTab.addEventListener('click', quadRedraw);
        cubicTab.addEventListener('click', cubicRedraw);
        linearTab.addEventListener('click', linearRedraw);
    </script>
</body>
</html>